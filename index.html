<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Honey Meadow</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h1>flowers.htl.dev üêù</h1>
  <div class="play-area" id="playArea"></div>
  <div class="stats">Honey: <span class="value" id="honey">0</span></div>
  <div class="connection-status disconnected" id="connectionStatus">‚ö´ Disconnected</div>

  <!-- Non-admin QR modal -->
  <div class="modal" id="qrModal" aria-hidden="true">
    <div class="modal-backdrop" data-close-modal></div>
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="qrTitle">
      <strong id="qrTitle" style="font-size: clamp(14px,2.2vw,24px)">Scan to join</strong>
      <img src="qr.png" alt="Join QR code" />
      <button class="modal-close" data-close-modal>Close</button>
    </div>
  </div>

  <script src="sse-connection.js"></script>
  <script>
    // ====== Backend URLs ======
    const SERVER = "https://flowers-backend.htl.dev";
    const LEVEL_URL = SERVER + "/api/level";
    const ADMIN_RESTART_URL = SERVER + "/api/admin/restart";
    const HARVEST_URL = (id) => SERVER + "/api/harvest/" + id;
    const EVENTS_URL = SERVER + "/api/events";

    // ====== State ======
    let levelData;
    const playArea = document.getElementById("playArea");
    const honeyEl = document.getElementById("honey");
    const connectionStatusEl = document.getElementById("connectionStatus");
    const qrModal = document.getElementById("qrModal");
    const isAdmin = new URLSearchParams(window.location.search).get("admin") === "true";
    let userHoney = 0;

    // ====== Audio System ======
    const audioCache = {};
    
    function loadAudio(filename) {
      if (!audioCache[filename]) {
        audioCache[filename] = new Audio(filename);
        audioCache[filename].preload = "auto";
        // Handle loading errors gracefully
        audioCache[filename].onerror = () => {
          console.warn(`Failed to load audio file: ${filename}`);
        };
      }
      return audioCache[filename];
    }

    function playSound(filename, volume = 1.0) {
      try {
        const audio = loadAudio(filename);
        audio.volume = Math.max(0, Math.min(1, volume));
        // Clone the audio to allow multiple simultaneous plays
        const audioClone = audio.cloneNode();
        audioClone.play().catch(e => {
          console.warn(`Failed to play sound ${filename}:`, e);
        });
      } catch (e) {
        console.warn(`Error playing sound ${filename}:`, e);
      }
    }

    // Preload sounds
    loadAudio('slurp.mp3');
    loadAudio('bump.mp3');

    // ====== Layout helpers ======
    function resizePlayArea() {
      const aspect = 9/16;
      const availableHeight = window.innerHeight - 80; 
      const availableWidth = window.innerWidth;
      let height = availableHeight;
      let width = height * aspect;
      if (width > availableWidth) {
        width = availableWidth;
        height = width / aspect;
      }
      playArea.style.width = width + "px";
      playArea.style.height = height + "px";
    }

    function updateFill(flowerEl) {
      const fillEl = flowerEl.querySelector(".fill");
      const fillValue = parseFloat(flowerEl.dataset.fill);
      fillEl.style.transform = `scale(${fillValue})`;
    }

    // ====== Flower creation ======
    function createFlower(data) {
      const root = document.createElement("div");
      root.className = "flower";
      root.dataset.fill = data.fill;
      root.dataset.rate = data.rate;
      if (data.id) root.dataset.id = data.id; // important for SSE updates

      const areaW = playArea.clientWidth;
      const areaH = playArea.clientHeight;
      const px = data.x * areaW;
      const py = data.y * areaH;
      const size = data.size * areaH;

      root.style.width = size + "px";
      root.style.height = size + "px";
      root.style.left = px - size/2 + "px";
      root.style.top = py - size/2 + "px";

      // Petals
      for (let i = 0; i < data.petals; i++) {
        const petal = document.createElement("div");
        petal.className = "petal";
        petal.style.width = size * 0.6 + "px";
        petal.style.height = size * 0.6 + "px";
        petal.style.background = data.color;
        petal.style.top = size * 0.2 + "px";
        petal.style.left = size * 0.2 + "px";
        petal.style.transform = `rotate(${i * (360 / data.petals)}deg) translate(0, -${size * 0.3}px)`;
        root.appendChild(petal);
      }

      // Center + fill
      const centerSize = size * 0.35;
      const fillSize = centerSize * 1.1;

      const fillEl = document.createElement("div");
      fillEl.className = "fill";
      fillEl.style.width = fillSize + "px";
      fillEl.style.height = fillSize + "px";
      fillEl.style.top = (size - fillSize)/2 + "px";
      fillEl.style.left = (size - fillSize)/2 + "px";
      root.appendChild(fillEl);

      const centerEl = document.createElement("div");
      centerEl.className = "center";
      centerEl.style.width = centerSize + "px";
      centerEl.style.height = centerSize + "px";
      centerEl.style.top = (size - centerSize)/2 + "px";
      centerEl.style.left = (size - centerSize)/2 + "px";
      root.appendChild(centerEl);

      centerEl.addEventListener("click", async (ev) => {
        try {
          const id = data.id ?? root.dataset.id;
          const res = await fetch(HARVEST_URL(id), { method: "POST" });
          if (!res.ok) return;

          const json = await res.json(); // { flowerId, honey, fill? }
          const gained = Number(json.honey) || 0;

          // Update UI based on server response
          const el = playArea.querySelector(`.flower[data-id="${json.flowerId}"]`) || root;
          if (typeof json.fill === "number") {
            el.dataset.fill = json.fill;
          } else if (gained > 0) {
            el.dataset.fill = 0;
          }
          updateFill(el);

          if (gained > 0) {
            userHoney += Math.round(gained * 10);
            honeyEl.textContent = userHoney;
            
            // Play slurp sound when successfully draining honey
            playSound('slurp.mp3', 0.7); // 70% volume
          } else {
            centerEl.classList.remove("no-honey");
            void centerEl.offsetWidth;
            centerEl.classList.add("no-honey");

            // Play bump sound when clicking empty flower
            playSound('bump.mp3', 0.6); // 60% volume

            if (navigator.vibrate) navigator.vibrate(15);
          }
        } catch (e) {
          console.error("harvest failed", e);
        }
      });

      updateFill(root);
      return root;
    }

    function buildLevel() {
      if (!levelData || !Array.isArray(levelData.flowers)) {
        console.error("Invalid or missing level payload", levelData);
        return;
      }
      playArea.innerHTML = "";
      levelData.flowers.forEach(f => playArea.appendChild(createFlower(f)));
    }

    // ====== Data I/O ======
    async function fetchLevel() {
      const res = await fetch(LEVEL_URL);
      if (!res.ok) throw new Error("Failed to load level");
      levelData = await res.json();
    }

    // ====== Admin / QR UI ======
    function openQrModal() {
      qrModal.classList.add("open");
      qrModal.setAttribute("aria-hidden", "false");
      document.addEventListener("keydown", escClose);
    }
    function closeQrModal() {
      qrModal.classList.remove("open");
      qrModal.setAttribute("aria-hidden", "true");
      document.removeEventListener("keydown", escClose);
    }
    function escClose(e) { if (e.key === "Escape") closeQrModal(); }
    qrModal.addEventListener("click", (e) => {
      if (e.target.matches("[data-close-modal]")) closeQrModal();
    });

    function mountAdminOrQrButton() {
      // remove existing
      document.querySelectorAll(".admin-panel, .qr-fab").forEach(n => n.remove());

      if (isAdmin) {
        const panel = document.createElement("div");
        panel.className = "admin-panel";
        panel.innerHTML = `
          <div class="admin-title">Admin</div>
          <div class="admin-row">
            <button id="restartBtn">Restart Level</button>
          </div>
          <div class="admin-row">QR (join):</div>
          <img src="qr.png" alt="Join QR code" class="admin-qr" />
        `;
        document.body.appendChild(panel);

        document.getElementById("restartBtn").addEventListener("click", async () => {
          try {
            await fetch(ADMIN_RESTART_URL, { method: 'POST' });
            await init(); // get new level and render it
          } catch (e) { console.error(e); }
        });
      } else {
        const fab = document.createElement("button");
        fab.className = "qr-fab";
        fab.type = "button";
        fab.innerHTML = `üì∑ Show QR`;
        fab.addEventListener("click", openQrModal);
        document.body.appendChild(fab);
      }
    }

    // ====== Init / Resize ======
    async function init() {
      // Important: first dimension the layout, then load/render level
      resizePlayArea();
      try {
        await fetchLevel();
        buildLevel();
      } catch (e) {
        console.error("Error fetching level", e);
      }
    }

    function relayout() {
      // gleiche Level-Daten, nur neu positionieren
      resizePlayArea();
      if (levelData) buildLevel();
    }

    // Admin/QR mounten, initial rendern
    mountAdminOrQrButton();
    init();

    // Refill loop wie gehabt
    setInterval(() => {
      document.querySelectorAll(".flower").forEach(flowerEl => {
        let val = parseFloat(flowerEl.dataset.fill);
        let rate = parseFloat(flowerEl.dataset.rate);
        val = Math.min(1, val + rate);
        flowerEl.dataset.fill = val;
        updateFill(flowerEl);
      });
    }, 2000);

    // Only re-layout on resize (no re-fetch)
    window.addEventListener("resize", relayout);

    // ====== SSE Connection Setup ======
    // Create SSE connection manager
    const sseManager = new SSEConnectionManager(EVENTS_URL, {
      maxReconnectAttempts: 10,
      initialReconnectDelay: 1000,
      maxReconnectDelay: 30000,
      
      // Handle connection status changes
      onConnectionChange: (status, message) => {
        connectionStatusEl.className = `connection-status ${status}`;
        connectionStatusEl.textContent = message;
      },
      
      // Handle incoming messages
      onMessage: async (data, event) => {
        if (data.type === 'levelRestarted') {
          await init(); // get new level
        }
        
        if (data.type === "harvest") {
          const id = data.flowerId || data.id;
          if (!id) return;
          
          const flowerEl = playArea.querySelector(`.flower[data-id="${id}"]`);
          if (!flowerEl) return;
          
          flowerEl.dataset.fill = (typeof data.fill === "number") ? data.fill : 0;
          updateFill(flowerEl);
          
          // small visual feedback
          const center = flowerEl.querySelector(".center");
          if (center) {
            center.classList.remove("depleted");
            void center.offsetWidth;
            center.classList.add("depleted");
          }
        }
        if (data.type === "level-update") {
          const level = JSON.parse(data.level);
          levelData = level;
          buildLevel();
        }
      },
      
      // Handle errors
      onError: (error, type) => {
        console.error(`SSE Error (${type}):`, error);
      }
    });

    // Start the connection
    sseManager.connect();
  </script>
</body>
</html>
