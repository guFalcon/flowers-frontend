<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Honey Meadow</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h1 style="font-size: clamp(24px, 4vw, 48px); color:lightgoldenrodyellow;">flowers.htl.dev üêù</h1>
  <div class="play-area" id="playArea"></div>
  <div class="stats">Honey: <span class="value" id="honey">0</span></div>
  <div class="connection-status disconnected" id="connectionStatus">‚ö´ Disconnected</div>

  <!-- Non-admin QR modal -->
  <div class="modal" id="qrModal" aria-hidden="true">
    <div class="modal-backdrop" data-close-modal></div>
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="qrTitle">
      <strong id="qrTitle" style="font-size: clamp(14px,2.2vw,24px)">Scan to join</strong>
      <img src="qr.png" alt="Join QR code" />
      <button class="modal-close" data-close-modal>Close</button>
    </div>
  </div>

  <script src="sse-connection.js"></script>
  <script src="bee.js"></script>
  <script src="audio-system.js"></script>
  <script>
    // ====== Backend URLs ======
    const SERVER = "https://flowers-backend.htl.dev";
    //const SERVER = "http://localhost:8084"; // for local testing
    const LEVEL_URL = SERVER + "/api/level";
    const ADMIN_RESTART_URL = SERVER + "/api/admin/restart";
    const HARVEST_URL = (id) => SERVER + "/api/harvest/" + id;
    const EVENTS_URL = SERVER + "/api/events";

    // ====== State ======
    let levelData;
    const playArea = document.getElementById("playArea");
    const honeyEl = document.getElementById("honey");
    const connectionStatusEl = document.getElementById("connectionStatus");
    const qrModal = document.getElementById("qrModal");
    const isAdmin = new URLSearchParams(window.location.search).get("admin") === "true";
    let userHoney = 0;

    const audioSystem = new AudioSystem();
    // Register sounds
    audioSystem.register('bee', 'bee-loop.mp3', { loop: true, volume: 0.5 });
    audioSystem.register('ambient', 'bees.mp3', { loop: true, volume: 0.3 });
    audioSystem.register('slurp', 'slurp.mp3', { volume: 0.7 });
    audioSystem.register('bump', 'bump.mp3', { volume: 0.6 });

    // Overcome browser autoplay restrictions: play ambient sound on first user interaction
    document.body.addEventListener('pointerdown', () => {
      audioSystem.play('ambient');
    }, { once: true });
    
    // ====== Audio System ======
    const audioCache = {};
    
    function loadAudio(filename) {
      if (!audioCache[filename]) {
        audioCache[filename] = new Audio(filename);
        audioCache[filename].preload = "auto";
        // Handle loading errors gracefully
        audioCache[filename].onerror = () => {
          console.warn(`Failed to load audio file: ${filename}`);
        };
      }
      return audioCache[filename];
    }

    // ====== Layout helpers ======
    function resizePlayArea() {
      const aspect = 9/16;
      const availableHeight = window.innerHeight - 80; 
      const availableWidth = window.innerWidth;
      let height = availableHeight;
      let width = height * aspect;
      if (width > availableWidth) {
        width = availableWidth;
        height = width / aspect;
      }
      playArea.style.width = width + "px";
      playArea.style.height = height + "px";
    }

    function updateFill(flowerEl) {
      const fillEl = flowerEl.querySelector(".fill");
      const fillValue = parseFloat(flowerEl.dataset.fill);
      fillEl.style.transform = `scale(${fillValue})`;
    }

    // ====== Flower creation ======
    function createFlower(data) {
      const root = document.createElement("div");
      root.className = "flower";
      root.dataset.fill = data.fill;
      root.dataset.rate = data.rate;
      if (data.id) root.dataset.id = data.id; // important for SSE updates

      const areaW = playArea.clientWidth;
      const areaH = playArea.clientHeight;
      const px = data.x * areaW;
      const py = data.y * areaH;
      const size = data.size * areaH;

      root.style.width = size + "px";
      root.style.height = size + "px";
      root.style.left = px - size/2 + "px";
      root.style.top = py - size/2 + "px";

      // Petals (support petalColors array if present)
      for (let i = 0; i < data.petals; i++) {
        const petal = document.createElement("div");
        petal.className = "petal";
        petal.style.width = size * 0.6 + "px";
        petal.style.height = size * 0.6 + "px";
        // Use petalColors[i] if available, else fallback to data.color
        if (Array.isArray(data.petalColors) && data.petalColors[i]) {
          petal.style.background = data.petalColors[i];
        } else {
          petal.style.background = data.color;
        }
        petal.style.top = size * 0.2 + "px";
        petal.style.left = size * 0.2 + "px";
        petal.style.transform = `rotate(${i * (360 / data.petals)}deg) translate(0, -${size * 0.3}px)`;
        root.appendChild(petal);
      }

      // Center + fill
      const centerSize = size * 0.35;
      const fillSize = centerSize * 1.1;

      const fillEl = document.createElement("div");
      fillEl.className = "fill";
      fillEl.style.width = fillSize + "px";
      fillEl.style.height = fillSize + "px";
      fillEl.style.top = (size - fillSize)/2 + "px";
      fillEl.style.left = (size - fillSize)/2 + "px";
      root.appendChild(fillEl);

      const centerEl = document.createElement("div");
      centerEl.className = "center";
      centerEl.style.width = centerSize + "px";
      centerEl.style.height = centerSize + "px";
      centerEl.style.top = (size - centerSize)/2 + "px";
      centerEl.style.left = (size - centerSize)/2 + "px";
      // Use stampColor if present, else default
      if (typeof data.stampColor === "string" && data.stampColor) {
        centerEl.style.background = data.stampColor;
      }
      root.appendChild(centerEl);

      updateFill(root);
      return root;
    }

    let bee = null;

    function buildLevel() {
      if (!levelData || !Array.isArray(levelData.flowers)) {
        console.error("Invalid or missing level payload", levelData);
        return;
      }
      // Remove all flowers, but NOT the bee
      Array.from(playArea.children).forEach(child => {
        if (!child.classList.contains('flower')) {
          // leave non-flower elements (like the bee)
          return;
        }
        playArea.removeChild(child);
      });
      levelData.flowers.forEach(f => playArea.appendChild(createFlower(f)));
      if (!bee) bee = new Bee(playArea, audioSystem);
      bee.update();

      if (bee.isFlying && bee.flightEndTime) {
        const now = performance.now();
        const remaining = bee.flightEndTime - now;
        if (remaining > 0) {
          bee.stopJitter();         // Stop any current jitter
          bee.startJitter(remaining); // Restart jitter for the remaining time
        }
      }
    }

    // ====== Data I/O ======
    async function fetchLevel() {
      const res = await fetch(LEVEL_URL);
      if (!res.ok) throw new Error("Failed to load level");
      levelData = await res.json();
    }

    // ====== Admin / QR UI ======
    function openQrModal() {
      qrModal.classList.add("open");
      qrModal.setAttribute("aria-hidden", "false");
      document.addEventListener("keydown", escClose);
    }
    function closeQrModal() {
      qrModal.classList.remove("open");
      qrModal.setAttribute("aria-hidden", "true");
      document.removeEventListener("keydown", escClose);
    }
    function escClose(e) { if (e.key === "Escape") closeQrModal(); }
    qrModal.addEventListener("click", (e) => {
      if (e.target.matches("[data-close-modal]")) closeQrModal();
    });

    function mountAdminOrQrButton() {
      // remove existing
      document.querySelectorAll(".admin-panel, .qr-fab").forEach(n => n.remove());

      if (isAdmin) {
        const panel = document.createElement("div");
        panel.className = "admin-panel";
        panel.innerHTML = `
          <div class="admin-title">Admin</div>
          <div class="admin-row">
            <button id="restartBtn">Restart Level</button>
          </div>
          <div class="admin-row">QR (join):</div>
          <img src="qr.png" alt="Join QR code" class="admin-qr" />
        `;
        document.body.appendChild(panel);

        document.getElementById("restartBtn").addEventListener("click", async () => {
          try {
            await fetch(ADMIN_RESTART_URL, { method: 'POST' });
            await init(); // get new level and render it
          } catch (e) { console.error(e); }
        });
      } else {
        const fab = document.createElement("button");
        fab.className = "qr-fab";
        fab.type = "button";
        fab.innerHTML = `üì∑ Show QR`;
        fab.addEventListener("click", openQrModal);
        document.body.appendChild(fab);
      }
    }

    // ====== Init / Resize ======
    async function init() {
      // Important: first dimension the layout, then load/render level
      resizePlayArea();
      try {
        await fetchLevel();
        buildLevel();
      } catch (e) {
        console.error("Error fetching level", e);
      }
    }

    function relayout() {
      resizePlayArea();
      if (levelData) {
        buildLevel();
        if (!bee) bee = new Bee(playArea); {
          bee.setTint('#FFD600');
          bee.moveTo(0.5, 0.5);
        }
      }
    }

    // Admin/QR mount, initial render
    mountAdminOrQrButton();
    init();

    // On pointer down, move bee and harvest if needed
    playArea.addEventListener('pointerdown', async (e) => {
      const rect = playArea.getBoundingClientRect();
      const relX = (e.clientX - rect.left) / rect.width;
      const relY = (e.clientY - rect.top) / rect.height;
      const duration = bee.getTravelDurationInMillis(relX, relY);

      bee.flightId++; // Increment for a new flight
      const thisFlight = bee.flightId;

      bee.moveTo(relX, relY);

      // Wait for bee to "fly" there
      await new Promise(res => setTimeout(res, duration));

      // Only harvest if this is still the latest flight
      if (thisFlight !== bee.flightId) return;

      // Find the closest center under the click (relative to playArea)
      const centers = Array.from(playArea.querySelectorAll('.center'));
      let minDist = Infinity, closest = null;
      centers.forEach(center => {
        const crect = center.getBoundingClientRect();
        const cx = (crect.left + crect.width/2 - rect.left) / rect.width;
        const cy = (crect.top + crect.height/2 - rect.top) / rect.height;
        const dist = Math.hypot(cx - relX, cy - relY);
        if (dist < (crect.width/2)/rect.width) { // inside the center
          if (dist < minDist) {
            minDist = dist;
            closest = center;
          }
        }
      });
      if (closest) {
        const root = closest.closest('.flower');
        const id = root?.dataset.id;
        const data = levelData.flowers.find(f => f.id == id);
        if (data) {
          harvestFlower(closest, data, root);
        }
      }
    });

    async function harvestFlower(centerEl, data, root) {
      try {
        const id = data.id ?? root.dataset.id;
        const res = await fetch(HARVEST_URL(id), { method: "POST" });
        if (!res.ok) return;

        const json = await res.json(); // { flowerId, honey, fill? }
        const gained = Number(json.honey) || 0;

        // Update UI based on server response
        const el = playArea.querySelector(`.flower[data-id="${json.flowerId}"]`) || root;
        if (typeof json.fill === "number") {
          el.dataset.fill = json.fill;
          updateFill(el);
        } else if (gained > 0) {
          el.dataset.fill = 0;
          updateFill(el);
        }

        if (gained > 0) {
          userHoney += Math.round(gained * 10);
          honeyEl.textContent = userHoney;
          audioSystem.play('slurp');
        } else {
          audioSystem.play('bump');
          if (navigator.vibrate) navigator.vibrate(15);
        }
      } catch (e) {
        console.error("harvest failed", e);
      }
    }

    setInterval(() => {
      document.querySelectorAll(".flower").forEach(flowerEl => {
        let val = parseFloat(flowerEl.dataset.fill);
        let rate = parseFloat(flowerEl.dataset.rate);
        val = Math.min(1, val + rate);
        flowerEl.dataset.fill = val;
        updateFill(flowerEl);
      });
    }, 2000);

    // Only re-layout on resize (no re-fetch)
    window.addEventListener("resize", () => {
      relayout();
      if (bee) bee.update();
    });

    // ====== SSE Connection Setup ======
    // Create SSE connection manager
    const sseManager = new SSEConnectionManager(EVENTS_URL, {
      maxReconnectAttempts: 10,
      initialReconnectDelay: 1000,
      maxReconnectDelay: 30000,
      
      // Handle connection status changes
      onConnectionChange: (status, message) => {
        connectionStatusEl.className = `connection-status ${status}`;
        connectionStatusEl.textContent = message;
        if (status === "connected") {
          audioSystem.play('ambient');
        } else {
          audioSystem.pause('ambient');
        }
      },
      
      // Handle incoming messages
      onMessage: async (data, event) => {
        if (data.type === 'levelRestarted') {
          await init(); // get new level
        }
        
        if (data.type === "harvest") {
          const id = data.flowerId || data.id;
          if (!id) return;
          
          const flowerEl = playArea.querySelector(`.flower[data-id="${id}"]`);
          if (!flowerEl) return;
          
          flowerEl.dataset.fill = (typeof data.fill === "number") ? data.fill : 0;
          updateFill(flowerEl);
          
          // small visual feedback
          const center = flowerEl.querySelector(".center");
          if (center) {
            center.classList.remove("depleted");
            void center.offsetWidth;
            center.classList.add("depleted");
          }
        }
        if (data.type === "level-update") {
          const level = JSON.parse(data.level);
          levelData = level;
          buildLevel();
        }
      },
      
      // Handle errors
      onError: (error, type) => {
        console.error(`SSE Error (${type}):`, error);
      }
    });

    // Start the connection
    sseManager.connect();
  </script>
</body>
</html>
