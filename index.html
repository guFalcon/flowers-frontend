<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Honey Meadow</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h1 style="font-size: clamp(24px, 4vw, 48px); color:lightgoldenrodyellow;">flowers.htl.dev üêù</h1>
  <div class="play-area" id="playArea"></div>
  <div class="stats">Honey: <span class="value" id="honey">0</span></div>
  <div class="connection-status disconnected" id="connectionStatus">‚ö´ Disconnected</div>

  <!-- Non-admin QR modal -->
  <div class="modal" id="qrModal" aria-hidden="true">
    <div class="modal-backdrop" data-close-modal></div>
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="qrTitle">
      <strong id="qrTitle" style="font-size: clamp(14px,2.2vw,24px)">Scan to join</strong>
      <img src="qr.png" alt="Join QR code" />
      <button class="modal-close" data-close-modal>Close</button>
    </div>
  </div>

  <!-- Scripts -->
  <script src="sse-connection.js"></script>
  <script src="bee.js"></script>
  <script src="audio-system.js"></script>
  <script>
    console.log("App started");

    // ====== Backend URLs ======
    //const SERVER = "http://localhost:8084";
    const SERVER = "https://flowers.htl.dev";
    const LEVEL_URL = SERVER + "/api/level";
    const ADMIN_RESTART_URL = SERVER + "/api/admin/restart";
    const HARVEST_URL = (id) => SERVER + "/api/harvest/" + id;
    const EVENTS_URL = SERVER + "/api/events";
    const SET_TARGET_URL = (id) => SERVER + "/api/player/" + id + "/target";

    // ====== State ======
    let levelData;
    const playArea = document.getElementById("playArea");
    const honeyEl = document.getElementById("honey");
    const connectionStatusEl = document.getElementById("connectionStatus");
    const qrModal = document.getElementById("qrModal");
    const isAdmin = new URLSearchParams(window.location.search).get("admin") === "true";
    let userHoney = 0;
    let yourBeeId = null;

    // ====== Audio System ======
    const audioSystem = new AudioSystem();
    audioSystem.register('bee', 'bee-loop.mp3', { loop: true, volume: 0.5 });
    audioSystem.register('ambient', 'bees.mp3', { loop: true, volume: 0.3 });
    audioSystem.register('slurp', 'slurp.mp3', { volume: 0.7 });
    audioSystem.register('bump', 'bump.mp3', { volume: 0.6 });

    document.body.addEventListener('pointerdown', () => {
      audioSystem.play('ambient');
    }, { once: true });

    // Pause/resume all sounds when the window loses or gains focus
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        audioSystem.pauseAll?.(); // if you have pauseAll() implemented
        audioSystem.pause('bee');
        audioSystem.pause('ambient');
      } else {
        // Resume ambient but NOT bee loop (bee starts on movement)
        audioSystem.play('ambient');
      }
    });

    window.addEventListener("blur", () => {
      audioSystem.pause('bee');
      audioSystem.pause('ambient');
    });

    window.addEventListener("focus", () => {
      audioSystem.play('ambient');
    });

    // ====== Bee instances map ======
    const beeInstances = new Map();

    // ====== Layout helpers ======
    function resizePlayArea() {
      const aspect = 9 / 16;
      const availableHeight = window.innerHeight - 80;
      const availableWidth = window.innerWidth;
      let height = availableHeight;
      let width = height * aspect;
      if (width > availableWidth) {
        width = availableWidth;
        height = width / aspect;
      }
      playArea.style.width = width + "px";
      playArea.style.height = height + "px";
    }

    function updateFill(flowerEl) {
      const fillEl = flowerEl.querySelector(".fill");
      const fillValue = parseFloat(flowerEl.dataset.fill);
      fillEl.style.transform = `scale(${fillValue})`;
    }

    // ====== Flower creation ======
    function createFlower(data) {
      const root = document.createElement("div");
      root.className = "flower";
      root.dataset.fill = data.fill;
      root.dataset.rate = data.rate;
      if (data.id) root.dataset.id = data.id;

      const areaW = playArea.clientWidth;
      const areaH = playArea.clientHeight;
      const px = data.x * areaW;
      const py = data.y * areaH;
      const size = data.size * areaH;

      root.style.width = size + "px";
      root.style.height = size + "px";
      root.style.left = px - size / 2 + "px";
      root.style.top = py - size / 2 + "px";

      // Petals
      for (let i = 0; i < data.petals; i++) {
        const petal = document.createElement("div");
        petal.className = "petal";
        petal.style.width = size * 0.6 + "px";
        petal.style.height = size * 0.6 + "px";
        petal.style.background = (Array.isArray(data.petalColors) && data.petalColors[i]) 
          ? data.petalColors[i] 
          : data.color;
        petal.style.top = size * 0.2 + "px";
        petal.style.left = size * 0.2 + "px";
        petal.style.transform = `rotate(${i * (360 / data.petals)}deg) translate(0, -${size * 0.3}px)`;
        root.appendChild(petal);
      }

      // Center + fill
      const centerSize = size * 0.35;
      const fillSize = centerSize * 1.1;

      const fillEl = document.createElement("div");
      fillEl.className = "fill";
      fillEl.style.width = fillSize + "px";
      fillEl.style.height = fillSize + "px";
      fillEl.style.top = (size - fillSize) / 2 + "px";
      fillEl.style.left = (size - fillSize) / 2 + "px";
      root.appendChild(fillEl);

      const centerEl = document.createElement("div");
      centerEl.className = "center";
      centerEl.style.width = centerSize + "px";
      centerEl.style.height = centerSize + "px";
      centerEl.style.top = (size - centerSize) / 2 + "px";
      centerEl.style.left = (size - centerSize) / 2 + "px";
      if (data.stampColor) centerEl.style.background = data.stampColor;
      root.appendChild(centerEl);

      updateFill(root);
      return root;
    }

    function buildLevel() {
      if (!levelData || !Array.isArray(levelData.flowers)) return;
      Array.from(playArea.children).forEach(child => {
        if (child.classList.contains("flower")) playArea.removeChild(child);
      });
      levelData.flowers.forEach(f => playArea.appendChild(createFlower(f)));
    }

    // ====== Bee rendering ======
    function renderBees(bees = []) {
      if (!Array.isArray(bees)) bees = [];

      bees.forEach(b => {
        let bee = beeInstances.get(b.id);
        if (!bee) {
          bee = new Bee(playArea, audioSystem, b.id);
          bee.setTint(b.color);
          beeInstances.set(b.id, bee);
        }

        // üîë mark self vs other for styling (opacity + halo)
        if (b.id === yourBeeId) {
          bee.wrapper.classList.add('is-self');
          bee.wrapper.classList.remove('is-other');
        } else {
          bee.wrapper.classList.add('is-other');
          bee.wrapper.classList.remove('is-self');
        }

        // movement (target preferred, fallback to current pos)
        if (typeof b.targetX === "number" && typeof b.targetY === "number") {
          const dx = Math.abs(b.targetX - bee.beeRelX);
          const dy = Math.abs(b.targetY - bee.beeRelY);
          if (dx > 0.001 || dy > 0.001) bee.moveTo(b.targetX, b.targetY);
        } else if (typeof b.x === "number" && typeof b.y === "number") {
          bee.moveTo(b.x, b.y);
        }
      });

      // GC
      for (const [id, inst] of beeInstances) {
        if (!bees.find(b => b.id === id)) {
          inst.destroy?.();
          beeInstances.delete(id);
        }
      }
    }

    // ====== Data I/O ======
    async function fetchLevel() {
      const res = await fetch(LEVEL_URL);
      if (!res.ok) throw new Error("Failed to load level");
      levelData = await res.json();
      if (levelData?.yourBeeId) yourBeeId = levelData.yourBeeId;
    }

    // ====== Admin/QR ======
    function openQrModal() {
      qrModal.classList.add("open");
      qrModal.setAttribute("aria-hidden", "false");
      document.addEventListener("keydown", escClose);
    }
    function closeQrModal() {
      qrModal.classList.remove("open");
      qrModal.setAttribute("aria-hidden", "true");
      document.removeEventListener("keydown", escClose);
    }
    function escClose(e) { if (e.key === "Escape") closeQrModal(); }

    function mountAdminOrQrButton() {
      document.querySelectorAll(".admin-panel, .qr-fab").forEach(n => n.remove());
      if (isAdmin) {
        const panel = document.createElement("div");
        panel.className = "admin-panel";
        panel.innerHTML = `
          <div class="admin-title">Admin</div>
          <div class="admin-row">
            <button id="restartBtn">Restart Level</button>
          </div>
          <div class="admin-row">QR (join):</div>
          <img src="qr.png" alt="Join QR code" class="admin-qr" />
        `;
        document.body.appendChild(panel);
        document.getElementById("restartBtn").addEventListener("click", async () => {
          await fetch(ADMIN_RESTART_URL, { method: "POST" });
          await init();
        });
      } else {
        const fab = document.createElement("button");
        fab.className = "qr-fab";
        fab.type = "button";
        fab.innerHTML = `üì∑ Show QR`;
        fab.addEventListener("click", openQrModal);
        document.body.appendChild(fab);
      }
    }

    // ====== Init ======
    async function init() {
      resizePlayArea();
      try {
        await fetchLevel();
        buildLevel();
        renderBees(levelData?.bees || []);
      } catch (e) { console.error("Error fetching level", e); }
    }

    // ====== SSE Connection ======
    const sseManager = new SSEConnectionManager(EVENTS_URL, {
      onConnectionChange: (status, message) => {
        connectionStatusEl.className = `connection-status ${status}`;
        connectionStatusEl.textContent = message;
        if (status === "connected") audioSystem.play("ambient");
        else audioSystem.pause("ambient");
      },

      onMessage: async (data) => {
        if (data.type === "levelRestarted") {
          await init();
        } else if (data.type === "harvest") {
          const id = data.flowerId || data.id;
          const flowerEl = playArea.querySelector(`.flower[data-id="${id}"]`);
          if (!flowerEl) return;
          flowerEl.dataset.fill = typeof data.fill === "number" ? data.fill : 0;
          updateFill(flowerEl);
          const center = flowerEl.querySelector(".center");
          if (center) {
            center.classList.remove("depleted");
            void center.offsetWidth;
            center.classList.add("depleted");
          }
        } else if (data.type === "level-update") {
          let level = data.level;
          if (typeof level === "string") {
            try { level = JSON.parse(level); } catch { return; }
          }
          if (level?.yourBeeId) yourBeeId = level.yourBeeId;
          levelData = level;
          buildLevel();
          renderBees(levelData.bees || []);
        }
      }
    });

    // ====== Start ======
    sseManager.connect();
    mountAdminOrQrButton();
    init();

    // ===== Event Listeners ======
    playArea.addEventListener("pointerdown", (e) => {
      if (!yourBeeId) return;

      const rect = playArea.getBoundingClientRect();
      const relX = (e.clientX - rect.left) / rect.width;
      const relY = (e.clientY - rect.top) / rect.height;

      const myBee = beeInstances?.get?.(yourBeeId);
      if (!myBee) {
        console.warn("No bee instance for yourBeeId yet");
        return;
      }

      myBee.incrementFlightId();
      const thisFlightId = myBee.flightId;
      const duration = myBee.moveTo(relX, relY);

      fetch(SET_TARGET_URL(yourBeeId), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ x: relX, y: relY })
      })
      .then(r => {
        // start local flight timer (acts like await new Promise(...))
        setTimeout(() => {
          // Only harvest if this is still the latest flight
          if (thisFlightId !== myBee.flightId) return;

          // Find the closest flower center under click
          const centers = Array.from(playArea.querySelectorAll(".center"));
          let minDist = Infinity, closest = null;
          centers.forEach(center => {
            const crect = center.getBoundingClientRect();
            const cx = (crect.left + crect.width / 2 - rect.left) / rect.width;
            const cy = (crect.top + crect.height / 2 - rect.top) / rect.height;
            const dist = Math.hypot(cx - relX, cy - relY);
            if (dist < (crect.width / 2) / rect.width) {
              if (dist < minDist) {
                minDist = dist;
                closest = center;
              }
            }
          });

          // trigger harvest if bee arrived and target still valid
          if (closest) {
            const root = closest.closest(".flower");
            const id = root?.dataset.id;
            const data = levelData.flowers.find(f => f.id == id);
            if (data) {
              harvestFlower(closest, data, root);
            }
          }
        }, duration);
      }).catch(e => console.error("Failed to set target", e));
    });
    
    async function harvestFlower(centerEl, data, root) {
      try {
        const id = data.id ?? root.dataset.id;
        const res = await fetch(HARVEST_URL(id), { method: "POST" });
        if (!res.ok) return;

        const json = await res.json(); // { flowerId, honey, fill? }
        const gained = Number(json.honey) || 0;

        // Update UI based on server response
        const el = playArea.querySelector(`.flower[data-id="${json.flowerId}"]`) || root;
        if (typeof json.fill === "number") {
          el.dataset.fill = json.fill;
          updateFill(el);
        } else if (gained > 0) {
          el.dataset.fill = 0;
          updateFill(el);
        }

        if (gained > 0) {
          userHoney += Math.round(gained * 10);
          honeyEl.textContent = userHoney;
          audioSystem.play('slurp');
        } else {
          audioSystem.play('bump');
          if (navigator.vibrate) navigator.vibrate(15);
        }
      } catch (e) {
        console.error("harvest failed", e);
      }
    }

    // Relayout on resize
    window.addEventListener("resize", () => {
      resizePlayArea();
      beeInstances.forEach(bee => bee.update());
    });

    // Passive flower fill growth
    setInterval(() => {
      document.querySelectorAll(".flower").forEach(flowerEl => {
        let val = parseFloat(flowerEl.dataset.fill);
        let rate = parseFloat(flowerEl.dataset.rate);
        val = Math.min(1, val + rate);
        flowerEl.dataset.fill = val;
        updateFill(flowerEl);
      });
    }, 2000);
  </script>
</body>
</html>
